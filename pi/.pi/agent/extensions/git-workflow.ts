/**
 * Git Workflow — /commit, /pr, /commit-and-pr
 *
 * Smart commits grouped by logical change with conventional commit messages.
 * PR creation via gh CLI with clean descriptions.
 */

import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

const NO_AI_RULE = `**No AI attribution** — NEVER add "generated by", "co-authored-by" with any AI/LLM name, "claude", "copilot", "gpt", "cursor", or any agent/AI mention in commits, PR title, or PR body.`;

const COMMIT_INSTRUCTIONS = `Inspect and commit all current changes. Follow these rules strictly:

1. Run \`git status\` and \`git diff\` (include \`--staged\` if needed) to inspect all changes
2. For untracked files, read their content to understand what they do
3. **Group** related files into logical commits (e.g. all files for one feature together)
4. Use **conventional commit** format: \`type(scope): message\`
   - Types: feat, fix, chore, refactor, docs, style, test, perf, ci, build
   - Scope is optional but recommended when clear
   - Message must be minimal, lowercase, no trailing period
5. ${NO_AI_RULE}
6. **Stage selectively** — \`git add <specific files>\` for each group, then \`git commit -m "..."\`
7. **Show the plan first** — list each planned commit with its files and message, then wait for my confirmation before executing
8. If a single commit makes more sense than multiple, that's fine — don't split unnecessarily`;

const PR_INSTRUCTIONS = (base: string, issue?: string) => {
  let prompt = `Create a pull request against \`${base}\` using the \`gh\` CLI.

1. Run \`git log ${base}..HEAD --oneline\` and \`git diff ${base}..HEAD --stat\` to understand changes
2. Generate a **clean PR title** using conventional format (feat, fix, chore, etc.)
3. Generate a **concise PR body** summarizing what changed and why
4. ${NO_AI_RULE}
5. Push the current branch first if needed: \`git push -u origin HEAD\`
6. **Show me the title and body first**, wait for confirmation, then run \`gh pr create --base ${base} --title "..." --body "..."\``;

  if (issue) {
    prompt += `\n7. Include \`Closes ${issue}\` at the end of the PR body`;
  }

  return prompt;
};

const COMMIT_AND_PR_INSTRUCTIONS = (base: string, issue?: string) => {
  let prompt = `First commit all changes, then create a pull request. Do this in two steps:

## Step 1 — Commit

${COMMIT_INSTRUCTIONS}

## Step 2 — Pull Request (after all commits are done)

1. Push branch: \`git push -u origin HEAD\`
2. Run \`git log ${base}..HEAD --oneline\` and \`git diff ${base}..HEAD --stat\`
3. Generate a clean PR title (conventional format) and concise body
4. ${NO_AI_RULE}
5. **Show me the PR title and body**, wait for confirmation, then run \`gh pr create --base ${base} --title "..." --body "..."\``;

  if (issue) {
    prompt += `\n6. Include \`Closes ${issue}\` at the end of the PR body`;
  }

  return prompt;
};

function parseArgs(args?: string): { base?: string; issue?: string } {
  const parts = args?.trim().split(/\s+/) || [];
  const issue = parts.find((p) => p.startsWith("#"));
  const base = parts.find((p) => !p.startsWith("#"));
  return { base, issue };
}

export default function (pi: ExtensionAPI) {
  pi.registerCommand("commit", {
    description: "Group and commit changes with conventional commit messages",
    handler: async (_args, ctx) => {
      const { stdout } = await pi.exec("git", ["status", "--porcelain"]);
      if (!stdout.trim()) {
        ctx.ui.notify("No changes to commit.", "warning");
        return;
      }
      pi.sendUserMessage(COMMIT_INSTRUCTIONS);
    },
  });

  pi.registerCommand("pr", {
    description: "Create a PR. Usage: /pr <base> [#issue]",
    handler: async (args, ctx) => {
      const { base, issue } = parseArgs(args);
      if (!base) {
        ctx.ui.notify("Usage: /pr <base-branch> [#issue]", "warning");
        return;
      }
      pi.sendUserMessage(PR_INSTRUCTIONS(base, issue));
    },
  });

  pi.registerCommand("commit-and-pr", {
    description:
      "Commit then create a PR. Usage: /commit-and-pr <base> [#issue]",
    handler: async (args, ctx) => {
      const { base, issue } = parseArgs(args);
      if (!base) {
        ctx.ui.notify(
          "Usage: /commit-and-pr <base-branch> [#issue]",
          "warning",
        );
        return;
      }

      const { stdout } = await pi.exec("git", ["status", "--porcelain"]);
      if (!stdout.trim()) {
        ctx.ui.notify("No changes to commit. Use /pr instead.", "warning");
        return;
      }

      pi.sendUserMessage(COMMIT_AND_PR_INSTRUCTIONS(base, issue));
    },
  });
}
